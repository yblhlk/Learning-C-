//#include<iostream>
//using namespace std;
//// 而C++11中新增了的右值引用语法特性，
//// 所以前面篇章所提到的引用都是叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
//
// /*左值是一个表示数据的表达式(如变量名或解引用的指针)，我们可以获取它的地址 + 可以对它赋值，
//   
//   *左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。
//   
//   *定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。
//   
//   *左值引用（&）就是给左值的引用，给左值取别名
// */
//int add(int a, int b)
//{
//	return a + b;
//}
//int main()
//{
//	// 1. 左值
//	{
//	//左值就是 变量/解引用的指针变量 等，是可以 获取地址和赋值 的标识符。
//		//左值是可以被赋值的表达式，它代表着可以被存储到内存中的值，并且可以获取其地址。
//		//字面字符串不能被赋值，所以它不是左值。（能取地址的不一定是左值）
//		//临时变量不能获取其地址，所以它也不是左值。（不能取地址的一定不是左值）
//		
//		//如以下的变量a,b,pa，解引用后的指针变量*pa就是左值
//		int a = 1;
//		int b = 2.1;
//		int* pa = &a;
//		//左值可以被赋值
//		a = 2;
//		b = 4;
//		pa = &b;
//		*pa = 3;
//		//左值能获取其地址
//		&a; &b; &pa; &(*pa);
//
//		//字面字符串不能被赋值，它不是左值。（能取地址的不一定是左值）
//		&("abcd");
//		//"abcd" = "abc";
//		
//		//临时变量因为不能获取其地址也不是左值。（不能取地址的一定不是左值）
//		// &add(a, b); //非&的函数返回的临时变量不是左值
//		// *(a * b);   //算术表达式的结果也是一个临时变量，也不是左值。
//	}
//
//	// 2. 左值引用
//	{
//		int a = 1;
//		int* pa = &a;
//		
//		//左值引用就是对左值（变量，解引用的指针变量 等）的引用
//		//以下的ra\rpa就是左值引用
//		int & ra = a; //reference : 引用
//		int* & rpa = pa; //指针的引用，int*是强调引用对象是一个指针
//		rpa = &a;
//	}
//
//	// 3.右值
//	{
//		/*右值也是一个表示数据的表达式，
//		  如：字面常量、表达式返回值，函数返回值(这个不能是左值引用返回)等等，
//		  右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址。
//		  
//		  右值本质就是一个临时变量或常量值
//
//		  但需要注意的是，这里说函数的返回值是右值，指的是传值返回的函数
//		 */
//		int a, b;
//		//以下是常见的右值
//		10 + 5;    //算术表达式
//		add(1, 2); //传值返回的函数返回值
//		a + b;     //算术表达式
//		"abcd";    //字面字符串
//	}
//
//	// 4.右值引用(&&)
//	{
//		int a = 0, b=0;
//
//		//右值引用（&&）就是对右值的引用，给右值取别名
//		int&& rra = 10 + 5;
//		//int& aa = 10 + 5;      //很明显左值引用不能引用右值
//		int&& rrb = add(1, 3);
//		//int&  lrb = add(1, 3); //很明显左值引用不能引用右值
//		int&& rrc = a + b;
//		//int& lrc = a + b;      //很明显左值引用不能引用右值
//		string&& rrd = "abcd";
//		//string& lrd = "abcd";  //很明显左值引用不能引用右值
//	}
//
//	//5.左值引用的特点
//	{
//		int a = 0, b = 0;
//		//左值引用使用的符号是 “ & ”
//		/*左值引用只能引用左值，不能引用右值
//		  因为右值的本质就是一个临时变量或常量。
//		  直接赋值给左值会导致权限放大。
//		 */
//		/*但是const左值引用既可引用左值，也可引用右值
//		  因为右值的本质就是一个临时变量或常量。
//		  const左值引用 引用 右值不会导致权限放大，而是权限的平移
//		 */
//		const int& lra = 1 + 2;
//		const int& lrb = add(1, 2);
//		const int& lrc = a + b;
//		const string& lrd = "abcd";
//	}
//
//	//6.右值引用的特点
//	{
//		int a, b;
//		int* pa;
//		//右值引用使用的符号是 “&& ”
//		//右值引用只能右值，不能引用左值
//		//但是右值引用可以 move以后的左值
//
//		//右值引用只能右值，不能引用左值
//		//int&& rra = a;
//		//int*&& rraa = pa; //报错:无法将右值引用绑定到左值
//
//		//但是右值引用可以 move以后的左值
//		int&& rra = move(a);
//		int*&& rrb = move(pa);
//	}
//
//	// 7.左值引用的使用场景和缺陷
//	{
//		/*左值引用的使用场景：
//			左值引用做参数：
//				a、做输出型参数  
//				b、大对象传参提高效率（左值引用做参数，能够完全避免传参时不必要的拷贝操作）
//			左值引用做返回值：
//				a、输出型返回对象，调用者可以修改返回对象  
//				b、减少拷贝，提高效率（左值引用做返回值，
//				并不能完全避免函数返回对象时不必要的拷贝操作，只对那些出了函数还存在的返回值有用）
//		*/
//
//		/*左值引用的缺陷：
//			左值引用对于出了作用域就销毁的对象无法使用，
//			比如函数返回的对象是一个局部变量，该变量出了函数作用域就被销毁了，
//			这种情况下不能用左值引用作为返回值，只能以传值的方式返回，这就是左值引用的短板
//			所以在上面说：并不能完全避免函数返回对象时不必要的拷贝操作
//		*/
//
//	}
//	//C++11提出右值引用就是为了解决左值引用的这个缺陷：左值引用对于出了作用域就销毁的对象无法使用
//	return 0;
//}
