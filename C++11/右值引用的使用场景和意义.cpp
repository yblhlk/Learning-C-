//右值引用通过增加移动构造和移动赋值方法 来 解决左值引用对于出了作用域就销毁的对象无法使用的问题
//移动构造
// 移动构造是一个构造函数，该构造函数的参数是右值引用类型的，
// 移动构造本质就是将传入右值的资源窃取过来，占为己有，这样就避免了进行深拷贝，所以它叫做移动构造，就是窃取别人的资源来构造自己

#include<iostream>
using namespace std;

class Student
{
public:
	Student(int age = 10){}
	Student(const Student& s)
	{
		cout << "调用拷贝构造" << endl;
	}
	Student(Student&& s) noexcept //不抛出异常
	{
		cout << "移动构造" << endl;
	}
	Student& operator = (Student&& s) noexcept
	{
		cout << "移动赋值" << endl;
		return *this;
	}
};

Student text()
{
	Student s;
	return s;
}

int main()
{
	// 如何创建一个右值对象？
	// 以移动构造为例
	// 1. 使用move将左值转化为右值
	Student s1(move(Student()));
	putchar(10);
	// 2. 临时对象：通过函数调用返回一个临时对象
	Student s2 = text(); //直接窃取函数返回的临时变量（将亡值）//这里被优化了，其实应该是两次移动构造
	putchar(10);
	// 3. lambda表达式和闭包：在C++11及更高版本中，lambda表达式和闭包通常被视为右值
	
	// 以移动赋值为例：
	//1.使用move将左值转化为右值
	s1 = (move(Student()));
	putchar(10);
	// 2. 临时对象：通过函数调用返回一个临时对象
	s2 = text();
	// 为什么这里是两次，一次移动构造，一次移动赋值？
	// 1. text()函数先调用移动构造构造了一个临时对象。
	// 2. 将临时对象移动赋值给s2。
	putchar(10);
	return 0;
}

// 移动构造：
//C++11之前，是没有增加移动构造的，由于拷贝构造采用的是 const左值引用接收参数，因此无论拷贝构造对象时传入的是左值还是右值，都会调用拷贝构造函数。
//在C++11之后，增加了移动构造，由于移动构造采用的是右值引用接收参数，因此如果拷贝构造对象时传入的是右值，那么就会调用移动构造函数（最匹配原则）。

// 移动赋值：
//在C++11之前，没有增加移动赋值，由于原有 operator=函数 采用的是 const左值引用接收参数，因此无论赋值时传入的是左值还是右值，都会调用原有的operator = 函数。
//在C++11之后，增加了移动赋值，由于移动赋值采用的是右值引用接收参数，因此如果赋值时传入的是右值，那么就会调用移动赋值函数（最匹配原则）。