/** 对象多态：
 *     派生类对象 可以赋值给 (基类的对象 / 基类的指针 / 基类的引用)
 *  行为多态：
 *     C++的多态不仅要通过 对象多态 还要通过 虚函数 来实现：这样才能做到一个基类的指针&引用使用同一方法时，呈现出不同效果。
 */

/** 重写与多态（Polymorphism）密切相关。
 * 通过基类指针或引用来调用重写后的方法时，将执行子类中的实现，而不是父类中的实现。
 * 这是动态绑定（Dynamic Binding）的一个例子。
 */

#include<iostream>
using std::cin;
using std::cout;
using std::endl;

class F
{
public :
	virtual ~F()
	{
		cout << "基类被析构" << endl;
	}
	void print()
	{
		cout << "父类的打印函数" << endl;
	}

	virtual void output()
	{
		cout << "父类的输出" << endl;
	}

	virtual F& printClass(F& f) //final在基类中使用，只能用于虚函数，用来表明该虚函数无法重写
	{
		cout << "F" << endl;
		return f;
	}
};

class S : public F
{
public:
	virtual ~S()
	{
		cout << "派生类被析构" << endl;
	}
	void print()
	{
		cout << "子类的打印函数" << endl;
	}

	virtual void output() //子类重写虚函数时可以不加virtual，但不规范，不建议这样写。
	{
		cout << "子类的输出" << endl;
	}
	// 协变也是重写的一种，即返回值类型是父类同名函数返回值类型的派生类
	virtual S& printClass(F& f) //override用来检查派生类是否完成基类 虚函数 的重写，只能在派生类中用，只能检查虚函数
	{
		F::printClass(f);
		cout << "S" << endl;
		return (S&)f;
	}
};

int main()
{
	//// 1. 行为多态
	//{
	//	cout << "===============================1.行为多态=============================" << endl;
	//	//使用指针实现多态
	//	F* f = new S();
	//	f->print(); //不是虚函数，光是对象多态无法实现行为多态
	//	f->output(); //是虚函数所以能实现行为多态。

	//	/** 行为多态实现的三个条件：
	//			对象多态(基类引用或指针，指向派生类对象)、调用的是虚函数、虚函数被子类重写。
	//	*/
	//}

	//// 2.重写(协变) 和 重定义
	//{
	//	cout << "===============================2.重写(协变) 和 重定义=============================" << endl;
	//	//协变：
	//	F f1;
	//	S s1;
	//	s1.printClass(f1);

	//	// C++的重写(覆盖)：
	//	// 发生在继承中：函数声明完全相同(协变除外)、必须是虚函数、访问权限不能比基类严格。

	//	// 重定义(隐藏)：
	//	// 也发生在继承中：不符合上述条件的同名函数，就是重定义

	//	//重载：
	//	//发生在同一作用域中，只要求函数名相同，参数列表不同。

	//	/* 重写与多态（Polymorphism）密切相关。
	//	 * 通过基类指针或引用来调用重写后的方法时，将执行子类中的实现，而不是父类中的实现。
	//	 * 这是动态绑定（Dynamic Binding）的一个例子。
	//	 */
	//}

	//3. 重写的一个重要用处是：重写析构函数，来保证对象多态时能正确释放子类的资源
	{
		cout << "===============================3.重写析构函数=============================" << endl;
		// 引用 
		// F& f = S(); //在C++中，你不能直接在声明引用的同时创建一个对象。引用的声明必须立即绑定到一个已经存在的对象上。
		F* f1 = new S();
		delete f1; //不重写析构函数，就调用父类的析构函数。
		// 如果我们不在子类中"重写"析构函数，对象多态时系统就不会调用子类的默认析构函数，所以子类的资源仍得不到释放。
		// 注意析构函数的重写要加上virtual。
	}
	return 0;
}